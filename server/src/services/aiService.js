import OpenAI from 'openai';
import { GoogleGenerativeAI } from '@google/generative-ai';

// Initialize AI services with Gemini as primary provider
let openai = null;
let genAI = null;
let initialized = false;

// Initialize AI services (call this after environment variables are loaded)
function initializeAIServices() {
  if (initialized) return;
  
  // Initialize Google Gemini as primary AI provider
  if (process.env.GEMINI_API_KEY && process.env.GEMINI_API_KEY !== 'your-gemini-api-key-here') {
    try {
      genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
      console.log('✅ Google Gemini initialized successfully (Primary AI Provider)');
    } catch (error) {
      console.warn('⚠️ Failed to initialize Google Gemini:', error.message);
    }
  } else {
    console.warn('⚠️ Google Gemini API key not configured - AI features will be limited');
  }

  // Initialize OpenAI as backup (optional)
  if (process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY !== 'your-openai-api-key-here') {
    try {
      openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
      });
      console.log('✅ OpenAI initialized successfully (Backup Provider)');
    } catch (error) {
      console.warn('⚠️ Failed to initialize OpenAI:', error.message);
    }
  } else {
    console.log('ℹ️ OpenAI not configured - using Gemini as primary AI provider');
  }
  
  initialized = true;
}

// Helper function to extract and parse JSON from Gemini responses
function extractJsonFromGeminiResponse(text) {
  try {
    // Try to find JSON wrapped in code blocks first
    const codeBlockMatch = text.match(/```(?:json)?\s*\n?([\s\S]*?)\n?```/);
    if (codeBlockMatch) {
      return JSON.parse(codeBlockMatch[1].trim());
    }
    
    // Try to find JSON object in the text (more flexible regex)
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    
    // If no JSON found, throw error
    throw new Error('No JSON found in response');
  } catch (error) {
    console.error('Failed to extract JSON from Gemini response:', error.message);
    console.error('Response text:', text);
    throw error;
  }
}

// AI Service class
class AIService {

  // Ensure AI services are initialized
  ensureInitialized() {
    if (!initialized) {
      initializeAIServices();
    }
  }

  // Generate drawing suggestions based on text description
  async generateDrawingSuggestions(description, boardContext = '') {
    this.ensureInitialized();
    
    // Try Gemini first (primary provider)
    if (genAI) {
      try {
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        const prompt = `You are a whiteboard assistant helping users create better diagrams. 

Context: "${boardContext}"
User Request: "${description}"

Generate 3-5 practical whiteboard drawing suggestions that would be helpful. 

Return ONLY a valid JSON object with this exact structure (no markdown formatting, no explanatory text):
{
  "suggestions": [
    {
      "type": "rectangle",
      "x": 100,
      "y": 100,
      "width": 120,
      "height": 60,
      "text": "Process Step",
      "fontSize": 16,
      "stroke": "#000000",
      "strokeWidth": 2,
      "fill": "transparent",
      "explanation": "A process box for organizing workflow steps"
    },
    {
      "type": "circle",
      "x": 300,
      "y": 100,
      "radius": 40,
      "text": "Start",
      "fontSize": 14,
      "stroke": "#000000",
      "strokeWidth": 2,
      "fill": "transparent",
      "explanation": "Start/end point for the process"
    }
  ]
}

Use these element types: rectangle, circle, text, arrow
For arrows, use: {"type": "arrow", "x": 200, "y": 120, "points": [0, 0, 100, 0], "stroke": "#000000", "strokeWidth": 2}
For text, use: {"type": "text", "x": 100, "y": 100, "text": "Label", "fontSize": 16, "fill": "#000000"}

Make suggestions practical and relevant to: "${description}"`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        console.log('Gemini drawing suggestions response:', text);
        
        const parsed = extractJsonFromGeminiResponse(text);
        return {
          ...parsed,
          message: 'Generated by Gemini AI'
        };
        
      } catch (error) {
        console.error('Gemini drawing suggestion generation error:', error.message);
        
        // Fallback to OpenAI if available
        if (openai) {
          try {
            return await this.generateDrawingSuggestionsWithOpenAI(description, boardContext);
          } catch (openaiError) {
            console.error('OpenAI drawing suggestions also failed:', openaiError.message);
          }
        }
      }
    }
    
    // Final fallback to manual suggestions
    console.log('Using manual fallback for drawing suggestions');
    return {
      suggestions: [
        {
          type: 'rectangle',
          position: { x: 100, y: 100 },
          properties: { width: 120, height: 60, text: 'Add your content here', fontSize: 16 },
          explanation: 'A basic rectangle for organizing content'
        },
        {
          type: 'text',
          position: { x: 100, y: 200 },
          properties: { text: 'Add descriptive text', fontSize: 16 },
          explanation: 'Text element for labels and descriptions'
        },
        {
          type: 'arrow',
          position: { x: 100, y: 300 },
          properties: { points: [0, 0, 100, 0] },
          explanation: 'Arrow to show flow or direction'
        }
      ],
      message: 'AI services unavailable - showing manual suggestions'
    };
  }

  // Helper method for OpenAI drawing suggestions fallback
  async generateDrawingSuggestionsWithOpenAI(description, boardContext) {
    const prompt = `
      Given this whiteboard context: "${boardContext}"
      And this user request: "${description}"
      
      Please suggest 3-5 drawing elements that would be helpful to add to the whiteboard.
      Format the response as JSON with this structure:
      {
        "suggestions": [
          {
            "type": "element_type",
            "position": {"x": 100, "y": 100},
            "properties": {...},
            "explanation": "Why this element is useful"
          }
        ]
      }
    `;

    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are an AI assistant that helps users create better whiteboard diagrams. Provide practical, actionable suggestions for drawing elements."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 500
    });

    const response = completion.choices[0].message.content;
    const parsed = JSON.parse(response);
    return {
      ...parsed,
      message: 'Generated by OpenAI (fallback)'
    };
  }

  // Generate flowchart from text description
  async generateFlowchart(description) {
    this.ensureInitialized();
    
    // Try Gemini first (primary provider)
    if (genAI) {
      try {
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        const prompt = `You are a flowchart expert. Create a flowchart for: "${description}"

Return ONLY a valid JSON object with this exact structure (no markdown formatting, no explanatory text):
{
  "nodes": [
    {
      "id": "start",
      "type": "start",
      "text": "Start",
      "x": 100,
      "y": 50,
      "width": 80,
      "height": 80
    },
    {
      "id": "process1",
      "type": "process", 
      "text": "First Process",
      "x": 100,
      "y": 150,
      "width": 120,
      "height": 60
    },
    {
      "id": "decision1",
      "type": "decision",
      "text": "Decision?",
      "x": 100,
      "y": 250,
      "width": 100,
      "height": 80
    }
  ],
  "connections": [
    {
      "from": "start",
      "to": "process1",
      "label": "Next"
    },
    {
      "from": "process1", 
      "to": "decision1",
      "label": "Next"
    }
  ]
}

Use node types: start, process, decision, end
Create a logical flow with start/end points, process steps, and decision points for: "${description}"`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        console.log('Gemini flowchart response:', text);
        
        const parsed = extractJsonFromGeminiResponse(text);
        return {
          ...parsed,
          message: 'Generated by Gemini AI'
        };
        
      } catch (error) {
        console.error('Gemini flowchart generation error:', error.message);
        
        // Fallback to OpenAI if available
        if (openai) {
          try {
            return await this.generateFlowchartWithOpenAI(description);
          } catch (openaiError) {
            console.error('OpenAI flowchart also failed:', openaiError.message);
          }
        }
      }
    }
    
    // Final fallback to manual flowchart
    console.log('Using manual fallback for flowchart');
    return {
      nodes: [
        { id: "start", type: "circle", text: "Start", position: { x: 100, y: 50 }, width: 80, height: 80 },
        { id: "process1", type: "rectangle", text: "Process 1", position: { x: 100, y: 150 }, width: 120, height: 60 },
        { id: "decision", type: "diamond", text: "Decision", position: { x: 100, y: 250 }, width: 100, height: 80 },
        { id: "process2", type: "rectangle", text: "Process 2", position: { x: 100, y: 350 }, width: 120, height: 60 },
        { id: "end", type: "circle", text: "End", position: { x: 100, y: 450 }, width: 80, height: 80 }
      ],
      connections: [
        { from: "start", to: "process1", label: "Next" },
        { from: "process1", to: "decision", label: "Next" },
        { from: "decision", to: "process2", label: "Yes" },
        { from: "decision", to: "end", label: "No" },
        { from: "process2", to: "end", label: "Next" }
      ],
      message: 'AI services unavailable - showing basic flowchart template'
    };
  }

  // Helper method for OpenAI flowchart fallback
  async generateFlowchartWithOpenAI(description) {
    const prompt = `
      Create a flowchart based on this description: "${description}"
      
      Generate a JSON structure representing the flowchart with:
      - Nodes (rectangles, diamonds, circles)
      - Connections (arrows between nodes)
      - Text content for each node
      - Logical flow
      
      Format as:
      {
        "nodes": [
          {
            "id": "node1",
            "type": "rectangle|diamond|circle",
            "text": "Node text",
            "position": {"x": 100, "y": 100},
            "width": 120,
            "height": 60
          }
        ],
        "connections": [
          {
            "from": "node1",
            "to": "node2",
            "label": "Yes/No/Next"
          }
        ]
      }
    `;

    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are an expert at creating flowcharts and process diagrams. Generate clear, logical flowcharts based on user descriptions."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.5,
      max_tokens: 1000
    });

    const response = completion.choices[0].message.content;
    const parsed = JSON.parse(response);
    return {
      ...parsed,
      message: 'Generated by OpenAI (fallback)'
    };
  }

  // Analyze board content and provide insights
  async analyzeBoardContent(elements, boardTitle = '') {
    this.ensureInitialized();
    
    // Try Gemini first (primary provider)
    if (genAI) {
      try {
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        
        const elementSummary = elements.map(el => ({
          type: el.type,
          content: el.text || el.tool || 'drawing',
          position: { x: el.x, y: el.y }
        }));

        const prompt = `You are a whiteboard analysis expert. Analyze this whiteboard content:

Title: "${boardTitle}"
Elements: ${JSON.stringify(elementSummary)}

Return ONLY a valid JSON object with this exact structure (no markdown formatting, no explanatory text):
{
  "analysis": {
    "type": "flowchart",
    "suggestions": [
      "Add more descriptive text to explain your ideas",
      "Use different shapes to organize information"
    ],
    "missingElements": [
      "Title or heading",
      "Descriptive labels"
    ],
    "organization": "Group related elements together and use consistent spacing"
  }
}

Provide insights about what type of diagram this is, improvement suggestions, missing elements, and organization recommendations.`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        console.log('Gemini analysis response:', text);
        
        const parsed = extractJsonFromGeminiResponse(text);
        return {
          ...parsed,
          message: 'Generated by Gemini AI'
        };
        
      } catch (error) {
        console.error('Gemini board analysis error:', error.message);
        
        // Fallback to OpenAI if available
        if (openai) {
          try {
            return await this.analyzeBoardContentWithOpenAI(elements, boardTitle);
          } catch (openaiError) {
            console.error('OpenAI analysis also failed:', openaiError.message);
          }
        }
      }
    }
    
    // Final fallback to manual analysis
    console.log('Using manual fallback for board analysis');
    return {
      analysis: {
        type: 'general',
        suggestions: [
          'Add more descriptive text to explain your ideas',
          'Use different shapes to organize information',
          'Connect related elements with arrows or lines',
          'Consider adding a title or legend'
        ],
        missingElements: [
          'Title or heading',
          'Descriptive labels',
          'Connections between elements'
        ],
        organization: 'Group related elements together and use consistent spacing'
      },
      message: 'AI services unavailable - showing basic analysis'
    };
  }

  // Helper method for OpenAI analysis fallback
  async analyzeBoardContentWithOpenAI(elements, boardTitle) {
    const elementSummary = elements.map(el => ({
      type: el.type,
      content: el.text || el.tool || 'drawing',
      position: { x: el.x, y: el.y }
    }));

    const prompt = `
      Analyze this whiteboard content:
      Title: "${boardTitle}"
      Elements: ${JSON.stringify(elementSummary)}
      
      Provide insights about:
      1. What type of diagram/board this appears to be
      2. Suggestions for improvement
      3. Missing elements that might be useful
      4. Organization recommendations
      
      Format as JSON:
      {
        "analysis": {
          "type": "flowchart|mindmap|wireframe|other",
          "suggestions": ["suggestion1", "suggestion2"],
          "missingElements": ["element1", "element2"],
          "organization": "recommendations"
        }
      }
    `;

    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are an expert at analyzing diagrams and whiteboards. Provide helpful insights and suggestions for improvement."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.3,
      max_tokens: 600
    });

    const response = completion.choices[0].message.content;
    const parsed = JSON.parse(response);
    return {
      ...parsed,
      message: 'Generated by OpenAI (fallback)'
    };
  }

  // Generate text suggestions for text elements
  async generateTextSuggestions(context, currentText = '') {
    this.ensureInitialized();
    
    // Try Gemini first (primary provider)
    if (genAI) {
      try {
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        const prompt = `You are a writing expert. Help improve this text:

Context: "${context}"
Current text: "${currentText}"

Return ONLY a valid JSON object with this exact structure (no markdown formatting, no explanatory text):
{
  "suggestions": [
    {
      "text": "Clear and concise title",
      "reason": "More professional and descriptive"
    },
    {
      "text": "Action-oriented description",
      "reason": "Encourages engagement and clarity"
    }
  ]
}

Suggest 3-5 alternative or improved text options. Consider clarity, conciseness, professional tone, and context relevance.`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        console.log('Gemini text suggestions response:', text);
        
        const parsed = extractJsonFromGeminiResponse(text);
        return {
          ...parsed,
          message: 'Generated by Gemini AI'
        };
        
      } catch (error) {
        console.error('Gemini text suggestion error:', error.message);
        
        // Fallback to OpenAI if available
        if (openai) {
          try {
            return await this.generateTextSuggestionsWithOpenAI(context, currentText);
          } catch (openaiError) {
            console.error('OpenAI text suggestions also failed:', openaiError.message);
          }
        }
      }
    }
    
    // Final fallback to manual text suggestions
    console.log('Using manual fallback for text suggestions');
    return {
      suggestions: [
        {
          text: 'Clear and concise title',
          reason: 'More professional and descriptive'
        },
        {
          text: 'Action-oriented description',
          reason: 'Encourages engagement and clarity'
        },
        {
          text: 'Key point or highlight',
          reason: 'Emphasizes important information'
        }
      ],
      message: 'AI services unavailable - showing basic text suggestions'
    };
  }

  // Helper method for OpenAI text suggestions fallback
  async generateTextSuggestionsWithOpenAI(context, currentText) {
    const prompt = `
      Context: "${context}"
      Current text: "${currentText}"
      
      Suggest 3-5 alternative or improved text options for this context.
      Consider:
      - Clarity and conciseness
      - Professional tone
      - Action-oriented language
      - Context relevance
      
      Format as JSON:
      {
        "suggestions": [
          {
            "text": "suggestion text",
            "reason": "why this is better"
          }
        ]
      }
    `;

    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are an expert at writing clear, professional text for diagrams and presentations."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 300
    });

    const response = completion.choices[0].message.content;
    const parsed = JSON.parse(response);
    return {
      ...parsed,
      message: 'Generated by OpenAI (fallback)'
    };
  }

  // Generate color scheme suggestions
  async generateColorSuggestions(boardType = 'general') {
    this.ensureInitialized();
    
    // Try Gemini first (primary provider)
    if (genAI) {
      try {
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
        const prompt = `You are a color theory expert. Suggest a professional color scheme for a ${boardType} whiteboard.

Return ONLY a valid JSON object with this exact structure (no markdown formatting, no explanatory text):
{
  "colorScheme": {
    "primary": "#2563eb",
    "secondary": "#7c3aed",
    "background": "#ffffff",
    "text": "#1f2937",
    "accent": "#f59e0b"
  },
  "description": "Professional blue and purple color scheme that works well for business presentations"
}

Include primary colors for main elements, secondary colors for highlights, background color, text colors, and accent colors. Ensure good contrast and accessibility.`;
        
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const text = response.text();
        
        console.log('Gemini color suggestions response:', text);
        
        const parsed = extractJsonFromGeminiResponse(text);
        return {
          ...parsed,
          message: 'Generated by Gemini AI'
        };
        
      } catch (error) {
        console.error('Gemini color suggestion error:', error.message);
        
        // Fallback to OpenAI if available
        if (openai) {
          try {
            return await this.generateColorSuggestionsWithOpenAI(boardType);
          } catch (openaiError) {
            console.error('OpenAI color suggestions also failed:', openaiError.message);
          }
        }
      }
    }
    
    // Final fallback to manual color suggestions
    console.log('Using manual fallback for color suggestions');
    return {
      colorScheme: {
        primary: '#2563eb',
        secondary: '#7c3aed',
        background: '#ffffff',
        text: '#1f2937',
        accent: '#f59e0b'
      },
      description: 'Professional blue and purple color scheme',
      message: 'AI services unavailable - showing default color scheme'
    };
  }

  // Helper method for OpenAI color suggestions fallback
  async generateColorSuggestionsWithOpenAI(boardType) {
    const prompt = `
      Suggest a professional color scheme for a ${boardType} whiteboard.
      Include:
      - Primary colors for main elements
      - Secondary colors for highlights
      - Background color
      - Text colors
      
      Format as JSON:
      {
        "colorScheme": {
          "primary": "#hexcode",
          "secondary": "#hexcode",
          "background": "#hexcode",
          "text": "#hexcode",
          "accent": "#hexcode"
        },
        "description": "Why this color scheme works well"
      }
    `;

    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are an expert at color theory and design. Suggest professional, accessible color schemes."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.5,
      max_tokens: 200
    });

    const response = completion.choices[0].message.content;
    const parsed = JSON.parse(response);
    return {
      ...parsed,
      message: 'Generated by OpenAI (fallback)'
    };
  }

  // Use Gemini for image analysis (if board has images)
  async analyzeImageWithGemini(imageData) {
    this.ensureInitialized();
    
    if (!genAI) {
      return {
        analysis: 'Image analysis not available - AI features not configured',
        suggestions: [
          'Consider adding descriptive text to your diagram',
          'Use different colors to organize information',
          'Add arrows or lines to show relationships'
        ]
      };
    }

    try {
      const model = genAI.getGenerativeModel({ model: "gemini-pro-vision" });
      
      const result = await model.generateContent([
        "Analyze this whiteboard image and describe what you see. Provide suggestions for improvement.",
        imageData
      ]);
      
      const response = await result.response;
      return {
        analysis: response.text(),
        message: 'Generated by Gemini AI'
      };
    } catch (error) {
      console.error('Gemini image analysis error:', error);
      throw new Error('Failed to analyze image with Gemini');
    }
  }
}

const aiService = new AIService();

export { initializeAIServices };
export default aiService;
